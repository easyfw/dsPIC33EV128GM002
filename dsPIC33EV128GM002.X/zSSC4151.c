/*
 * File:   ZSSC4151.c
 * Author: easyf
 *
 * Created on August 30, 2025, 4:38 PM
 */
#include <stdbool.h>
#include <stdint.h> 
#include "..\h\zSSC4151.h"

extern void dbg_putc (char c);
extern void dbg_put_hex_byte (uint8_t val);
extern void dbg_put_hex_word (uint16_t val);
extern void dbg_put_float (float temp);
extern void dbg_put_string (char *s);

// I2C
extern void I2C1_Init (void);
extern bool I2C1_Start (void);
extern bool I2C1_Stop (void);
extern bool I2C1_Restart (void);
extern bool I2C1_Write (uint8_t data);
extern uint8_t I2C1_Read (bool send_ack);
extern void I2C1_WaitForIdle (void);
extern void I2C1_Ack (void);
extern void I2C1_Nack (void);
extern void I2C_Scan (void);
extern int I2C1_SendByte (unsigned char data);

extern void delay_10ms (uint16_t num);
extern void delay_us (unsigned int us);

// ?????? ZSSC4151_Probe_CM ???
bool ZSSC4151_Probe_CM (void)
{
    uint8_t rx_buffer[4];

    dbg_put_string ("  Probe Step 1: Start\r\n");
    if (!I2C1_Start ())
    {
        dbg_put_string ("  -> FAILED\r\n");
        return false;
    }

    dbg_put_string ("  Probe Step 2: Write Address\r\n");
    if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
        dbg_put_string ("  -> FAILED (NACK or Timeout)\r\n");
        I2C1_Stop ();
        return false;
    }

    dbg_put_string ("  Probe Step 3: Write Command\r\n");
    if (!I2C1_Write (CMD_READ_OUTPUT_MEM))
    {
        dbg_put_string ("  -> FAILED (NACK or Timeout)\r\n");
        I2C1_Stop ();
        return false;
    }

  /*
  dbg_put_string("  Probe Step 4: Write Parameter\r\n");
  if (!I2C1_Write(0x17)) {
      dbg_put_string("  -> FAILED (NACK or Timeout)\r\n");
      I2C1_Stop();
      return false;
  }
   */

    dbg_put_string ("  Probe Step 5: Restart\r\n");
    if (!I2C1_Restart ())
    {
        dbg_put_string ("  -> FAILED\r\n");
        I2C1_Stop ();
        return false;
    }

    dbg_put_string ("  Probe Step 6: Write Read Address\r\n");
    if (!I2C1_Write (ZSSC4151_READ_ADDR))
    {
        dbg_put_string ("  -> FAILED (NACK or Timeout)\r\n");
        I2C1_Stop ();
        return false;
    }

    dbg_put_string ("  Probe Step 7: Reading bytes...\r\n");
    rx_buffer[0] = I2C1_Read (true);
    rx_buffer[1] = I2C1_Read (true);
    rx_buffer[2] = I2C1_Read (true);
    rx_buffer[3] = I2C1_Read (false);
    
    I2C1_Stop ();

    dbg_put_string ("  Probe RX Raw: ");
    for (int i = 0; i < 4; i++)
    {
        dbg_put_hex_byte (rx_buffer[i]);
        dbg_putc (' ');
    }
    dbg_put_string ("\r\n");

    for (int i = 0; i < 4; i++)
    {
        if (rx_buffer[i] == CMD_READ_OUTPUT_MEM)
        {
            dbg_put_string ("  -> Probe OK!\r\n");
            return true;
        }
    }

    dbg_put_string ("  -> FAILED (Echo mismatch)\r\n");
    return false;
}

//
void Crc16_update (uint16_t *crc, uint8_t data)
{
    *crc = *crc ^ ((uint16_t) data << 8);

    for (int i = 0; i < 8; i++)
    {
        if (*crc & 0x8000) *crc = (*crc << 1) ^ 0x1021;
        else *crc = (*crc << 1);
    }
}

//
uint16_t Calculate_ZSSC_CRC (const uint16_t *nvm_data)
{
    uint16_t crc = 0xFFFF;

    for (int i = 1; i < 0x79; i++)
    {
        uint16_t word = nvm_data[i];
        Crc16_update (&crc, (uint8_t) (word >> 8));
        Crc16_update (&crc, (uint8_t) (word & 0xFF));
    }

    return crc;
}

/**
 * @brief ??? ????? ???? 32??? ?????? ?¬à???? Helper ???
 */
int ZSSC4151_Read_Command_Response32 (uint8_t command, uint32_t *response_data)
{
    uint8_t b[5]; // command_echo + 32-bit data

    if (!I2C1_Start ()) return -1;
  
    if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }
  
    if (!I2C1_Write (command))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Restart ())
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (ZSSC4151_READ_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }

    for (int i = 0; i < 4; i++) b[i] = I2C1_Read (true);
    b[4] = I2C1_Read (false);

    if (!I2C1_Stop ()) return -1;

    // ? ?????(b[0])?? ????? ???????? ???????.
    *response_data = ((uint32_t) b[1] << 24) | ((uint32_t) b[2] << 16) | ((uint32_t) b[3] << 8) | b[4];
    return 0;
}

/**
 * @brief ZSSC4151?? ???? ????(IC Status) ????????? ????????.
 * @details WrClrIcStatus (0x61) ????? ?????? ??? ???? ?¡À???? ??????.
 * @return 0: ????, -1: ????
 */
int ZSSC4151_Clear_Status (void)
{
    const uint8_t CMD_CLEAR_STATUS = 0x61;
    const uint8_t CLEAR_ALL_MSB = 0xFF; // ??? ?¡À???? ????? ???? ?????
    const uint8_t CLEAR_ALL_LSB = 0xFF;

    if (!I2C1_Start ()) return -1;
    
    if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (CMD_CLEAR_STATUS))
    {
        I2C1_Stop ();
        return -1;
    }

    // 32??? ????? ???? (??? ????? 1?? ??????? ??? ?????)
    if (!I2C1_Write (CLEAR_ALL_MSB))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (CLEAR_ALL_LSB))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (CLEAR_ALL_MSB))
    {
        I2C1_Stop ();
        return -1;
    }
  
    if (!I2C1_Write (CLEAR_ALL_LSB))
    {
        I2C1_Stop ();
        return -1;
    }

    if (!I2C1_Stop ()) return -1;

    delay_us (500); // ????? ??? ?©£? ???
    return 0;
}

/**
 * @brief ZSSC4151?? ???? ???? ?? ???? ????????? ?¬à? UART?? ???????.
 * @details Command Mode???? ?????? ????.
 */
void ZSSC4151_Check_Status (void)
{
    uint32_t status_val;

    dbg_put_string ("\r\n--- Checking ZSSC4151 Status ---\r\n");

    // Failure Status ?¬Ò? (???©ª?????? ???? ????: ???? ???/??? ??)
    if (ZSSC4151_Read_Command_Response32 (0x62, &status_val) == 0)
    {
        dbg_put_string ("  FailureStatus (0x62): 0x");
        // 32??? ????? ???? ????/???? ???? ?¬Ú? ???
        dbg_put_hex_word ((uint16_t) (status_val >> 16));
        dbg_put_hex_word ((uint16_t) (status_val & 0xFFFF));

        if (status_val != 0) dbg_put_string (" <-- Application Error Detected!");
        dbg_put_string ("\r\n");
    }
    else dbg_put_string ("  Failed to read FailureStatus (0x62)\r\n");

    // IC Status ?¬Ò? (??????/????? ???? ????)
    if (ZSSC4151_Read_Command_Response32 (0x60, &status_val) == 0)
    {
        dbg_put_string ("  IC Status (0x60)      : 0x");
        dbg_put_hex_word ((uint16_t) (status_val >> 16));
        dbg_put_hex_word ((uint16_t) (status_val & 0xFFFF));
        if (status_val != 0) dbg_put_string (" <-- Firmware/HW Error Detected!");
        dbg_put_string ("\r\n");
    }
    else dbg_put_string ("  Failed to read IC Status (0x60)\r\n");
    
    dbg_put_string ("---------------------------------\r\n\r\n");
}

//==============================================================================
// ZSSC4151 NVM ?? ?? ??
//==============================================================================
//
int ZSSC4151_EnterCommandMode (void)
{
    if (!I2C1_Start ()) return -1;
    
    if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (CMD_START_CM))
    {
        I2C1_Stop ();
        return -1;
    }
  
    if (!I2C1_Write (CM_AUTH_KEY_MSB))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (CM_AUTH_KEY_LSB))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Stop ()) return -1;
    
    delay_10ms (1);
    return 0;
}

/**
 * @brief ZSSC4151?? Normal Operation Mode?? ???????.
 * @return 0: ????, -1: ????
 */
int ZSSC4151_Start_Normal_Mode (void)
{
    if (!I2C1_Start ()) return -1;
    
    if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Write (CMD_START_NOM))
    {
        I2C1_Stop ();
        return -1;
    }
    
    if (!I2C1_Stop ()) return -1;

    // Normal Mode?? ?????? ? ??????? ???? ?????? ???? ?©£? ???
    delay_10ms (5);

    return 0;
}

/*
 *  @brief NVM ???? ???? ?????? ???? ????(Lock)?? ????????. (??????)
 * @warning ?? ????? ?????? ???? ???? ¨¨??? ???? ??????? ????.
 * @return 0: ????, -1: ????
 */
int ZSSC4151_Unlock_NVM (void)
{
  // ???????? ??? ????: ????? 0x15, ???? ? 0x3C5B
  const uint8_t CMD_WR_NVM_AUTH = 0x15;
  const uint16_t AUTH_KEY = 0x3C5B;

  if (!I2C1_Start ()) return -1;
  if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
      I2C1_Stop ();
      return -1;
    }
  if (!I2C1_Write (CMD_WR_NVM_AUTH))
    {
      I2C1_Stop ();
      return -1;
    }

  // 16??? ???? ? ????
  if (!I2C1_Write ((uint8_t) (AUTH_KEY >> 8)))
    {
      I2C1_Stop ();
      return -1;
    } // MSB
  if (!I2C1_Write ((uint8_t) (AUTH_KEY & 0xFF)))
    {
      I2C1_Stop ();
      return -1;
    } // LSB

  if (!I2C1_Stop ()) return -1;

  delay_10ms (1); // ????? ????? ???? ¨£?? ???
  return 0;
}

/**
 * @brief ZSSC4151 NVM???? 1 ???? ?¬ß????. (?????? ??? ???? ???)
 * @details ?????(0x20)?? ???? ?????? ??????? ????????.
 */
int ZSSC4151_ReadNvmWord (uint8_t nvm_addr, uint16_t *read_data)
{
    const uint8_t CMD_READ_NVM = 0x24;
    uint8_t command_echo, msb, lsb;

    if (!I2C1_Start ()) return -1;
    if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }
    if (!I2C1_Write (CMD_READ_NVM))
    {
        I2C1_Stop ();
        return -1;
    }
    if (!I2C1_Write (0x00))
    {
        I2C1_Stop ();
        return -1;
    }
    if (!I2C1_Write (nvm_addr))
    {
        I2C1_Stop ();
        return -1;
    }

    if (!I2C1_Restart ())
    {
        I2C1_Stop ();
        return -1;
    }

    // --- 3???: ?????? ???? (?? 3?????) ---
    if (!I2C1_Write (ZSSC4151_READ_ADDR))
    {
        I2C1_Stop ();
        return -1;
    }

    // ???? ??? ???? ?¥ê? ????
    command_echo = I2C1_Read (true); // 1. ????? ????(Echo) ?????(0x24)?? ?¬Ñ? ???????. (ACK ????)
    msb = I2C1_Read (true); // 2. ???? ???????? MSB?? ?¬ß????. (ACK ????)
    lsb = I2C1_Read (false); // 3. ???? ???????? LSB?? ?¬ß????. (NACK ???????? ?¬Ò? ????)

    if (!I2C1_Stop ()) return -1;

    *read_data = ((uint16_t) msb << 8) | lsb;

    // ????? ??? ?©£? ?????? ???? ???? ????
    delay_us (100);

    return 0;
}

/**
 * @brief ZSSC4151 NVM?? 1 ???? ?????. (??????)
 * @details ?????(0x25) ?????? ???(16???)?? ??????(16???)?? ??? 32??? ?¥ì??? ????????.
 */
int ZSSC4151_WriteNvmWord (uint8_t nvm_addr, uint16_t write_data)
{
  const uint8_t CMD_WRITE_NVM = 0x25;

  if (!I2C1_Start ()) return -1;
  if (!I2C1_Write (ZSSC4151_WRITE_ADDR))
    {
      I2C1_Stop ();
      return -1;
    }
  if (!I2C1_Write (CMD_WRITE_NVM))
    {
      I2C1_Stop ();
      return -1;
    }

  // ???????? ??? ????: 32??? ?¥ì? = 16??? ??? + 16??? ??????
  // ??? ???? (???? ??????? 0)
  if (!I2C1_Write (0x00))
    {
      I2C1_Stop ();
      return -1;
    }
  if (!I2C1_Write (nvm_addr))
    {
      I2C1_Stop ();
      return -1;
    }

  // ?????? ????
  if (!I2C1_Write ((uint8_t) (write_data >> 8)))
    {
      I2C1_Stop ();
      return -1;
    }
  if (!I2C1_Write ((uint8_t) (write_data & 0xFF)))
    {
      I2C1_Stop ();
      return -1;
    }

  if (!I2C1_Stop ()) return -1;

  // ???? ???? ???? ?? t_NVM_prog ????? ??? ????? ?? ??????.
  // ?????????? t_NVM_prog = 10ms (max)
  delay_10ms (2);

  return 0;
}

/**
 * @brief ZSSC4151¿¡°Ô Æ¯Á¤ ÃøÁ¤ ÀÛ¾÷À» ½ÃÀÛÇÏ¶ó°í ¸í·ÉÇÕ´Ï´Ù.
 * @details CMD ¸ðµå¿¡¼­¸¸ ½ÇÇàÇØ¾ß ÇÕ´Ï´Ù. ÀÌ ÇÔ¼ö ½ÇÇà ÈÄ¿¡µµ CMD ¸ðµå´Â À¯ÁöµË´Ï´Ù.
 * @param taskNum ½ÇÇàÇÒ ÃøÁ¤ ÀÛ¾÷ ¹øÈ£ (0~31). ºê¸´Áö ÃøÁ¤Àº º¸Åë 0 ¶Ç´Â 1 ÀÔ´Ï´Ù.
 * @param repeats ÃøÁ¤ ¹Ýº¹ È½¼ö (0=1¹ø, 1=2¹ø, 2=4¹ø, ... n=2^n ¹ø ¹Ýº¹).
 * @param avgFactor Æò±Õ ÇÊÅÍ °è¼ö (0~7). 2^n À¸·Î ³ª´©´Â È¿°úÀÔ´Ï´Ù.
 * @return ¼º°ø ½Ã 0, ½ÇÆÐ ½Ã -1
 */
int ZSSC4151_StartMeasTask(uint8_t taskNum, uint8_t repeats, uint8_t avgFactor)
{
    uint16_t argument;

    // 1. Ä¿¸Çµå¿¡ ÇÊ¿äÇÑ 16ºñÆ® ÀÎÀÚ(argument)¸¦ ¹®¼­¿¡ µû¶ó »ý¼ºÇÕ´Ï´Ù.
    // Bits [4:0]  : taskNum (ÀÛ¾÷ ¹øÈ£)
    // Bits [11:8] : repeats (¹Ýº¹ È½¼ö)
    // Bits [14:12]: avgFactor (Æò±Õ °è¼ö)
    argument =  ((uint16_t)(avgFactor & 0x07) << 12) | \
                ((uint16_t)(repeats   & 0x0F) << 8)  | \
                ((uint16_t)(taskNum   & 0x1F));

    // 2. I2C Åë½Å ½ÃÀÛ
    if (!I2C1_Start()) return -1;

    // 3. ½½·¹ÀÌºê ÁÖ¼Ò(¾²±â) Àü¼Û
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR)) 
    {
        I2C1_Stop();
        return -1;
    }

    // 4. StrtMeasTask Ä¿¸Çµå Àü¼Û
    if (!I2C1_Write(CMD_STRT_MEAS_TASK)) 
    {
        I2C1_Stop();
        return -1;
    }

    // 5. 16ºñÆ® ÀÎÀÚ¸¦ 2¹ÙÀÌÆ®·Î ³ª´©¾î Àü¼Û (MSB ¸ÕÀú)
    if (!I2C1_Write((uint8_t)(argument >> 8))) 
    { // Argument MSB
        I2C1_Stop();
        return -1;
    }
    
    if (!I2C1_Write((uint8_t)(argument & 0xFF))) 
    { // Argument LSB
        I2C1_Stop();
        return -1;
    }

    // 6. I2C Åë½Å Á¾·á
    if (!I2C1_Stop()) return -1;

    // Âü°í: ÀÌ Ä¿¸Çµå´Â Áï½Ã ¿Ï·áµÇÁö ¾Ê½À´Ï´Ù.
    // È£Ãâ ÈÄ ZSSC4151ÀÌ ÃøÁ¤À» ¿Ï·áÇÒ ¶§±îÁö ¾à°£ÀÇ ½Ã°£ Áö¿¬ÀÌ ÇÊ¿äÇÕ´Ï´Ù.
    return 0;
}

/**
 * @brief ZSSC4151ÀÇ RAM Æ¯Á¤ À§Ä¡¿¡¼­ ¿øÇÏ´Â ¸¸Å­ÀÇ µ¥ÀÌÅÍ¸¦ ÀÐ¾î¿É´Ï´Ù. (Burst Mode)
 * @details CMD ¸ðµå ¶Ç´Â Normal ¸ðµå¿¡¼­ ¸ðµÎ »ç¿ë °¡´ÉÇÕ´Ï´Ù.
 * @param startAddr ÀÐ±â ½ÃÀÛÇÒ RAMÀÇ ³»ºÎ ÁÖ¼Ò (0~127)
 * @param wordCount ÀÐ¾î¿Ã µ¥ÀÌÅÍ °³¼ö (16ºñÆ® ¿öµå ´ÜÀ§)
 * @param readBuffer µ¥ÀÌÅÍ¸¦ ÀúÀåÇÒ ¹öÆÛÀÇ Æ÷ÀÎÅÍ (ÃÖ¼Ò wordCount * 2 ¹ÙÀÌÆ® Å©±â)
 * @return ¼º°ø ½Ã 0, ½ÇÆÐ ½Ã -1
 */
int ZSSC4151_ReadRamBurst(uint8_t startAddr, uint8_t wordCount, uint8_t* readBuffer)
{
    if (wordCount == 0) return 0; // ÀÐÀ» µ¥ÀÌÅÍ°¡ ¾øÀ¸¸é ¹Ù·Î ¼º°ø ¸®ÅÏ

    // 1. ÀÐÀ» À§Ä¡¸¦ ÁöÁ¤ÇÏ´Â Ä¿¸Çµå Àü¼Û (¾²±â Æ®·£Àè¼Ç)
    if (!I2C1_Start()) return -1;
    
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR)) 
    {
        I2C1_Stop();
        return -1;
    }
    
    if (!I2C1_Write(CMD_RD_OUT_MEM_BURST)) 
    {
        I2C1_Stop();
        return -1;
    }
    // ÀÎÀÚ Àü¼Û: ½ÃÀÛ ÁÖ¼Ò¿Í ÀÐÀ» ¿öµå °³¼ö
    // ¹®¼­»óÀ¸·Î´Â 16ºñÆ® ÀÎÀÚ ÇÏ³ªÁö¸¸, ±âÁ¸ ÄÚµå ½ºÅ¸ÀÏ°ú È£È¯¼ºÀ» À§ÇØ
    // º°µµÀÇ ¹ÙÀÌÆ®·Î Àü¼ÛÇÏ´Â °ÍÀÌ ¾ÈÁ¤ÀûÀÏ ¼ö ÀÖ½À´Ï´Ù.
    // ZSSC4151_Read_Output_Data ÇÔ¼ö¿¡¼­´Â ÁÖ¼Ò¿Í °³¼ö¸¦ º°µµ·Î º¸³À´Ï´Ù.
    // ÇØ´ç ¹®¼­¿¡¼­´Â word count°¡ 0ÀÌ¸é 1¿öµå¸¦ ÀÇ¹ÌÇÏ¹Ç·Î, 1À» »©¼­ Àü¼ÛÇÕ´Ï´Ù.
    if (!I2C1_Write(startAddr)) 
    {
        I2C1_Stop();
        return -1;
    }
    
    if (!I2C1_Write(wordCount -1)) 
    { // wordCount 1 -> arg 0, wordCount 2 -> arg 1 ...
        I2C1_Stop();
        return -1;
    }

    // 2. Restart ÈÄ ÀÐ±â Æ®·£Àè¼Ç ½ÃÀÛ
    if (!I2C1_Restart()) 
    {
        I2C1_Stop();
        return -1;
    }
    
    if (!I2C1_Write(ZSSC4151_READ_ADDR)) 
    {
        I2C1_Stop();
        return -1;
    }
    
    // 3. ZSSC4151·ÎºÎÅÍ µ¥ÀÌÅÍ ¼ö½Å
    // Ã¹ ¹ÙÀÌÆ®´Â Ä¿¸Çµå ¿¡ÄÚ(echo)ÀÌ¹Ç·Î ÀÐ¾î¼­ ¹ö¸³´Ï´Ù.
    (void)I2C1_Read(true); 

    // ½ÇÁ¦ µ¥ÀÌÅÍ ÀÐ±â
    uint16_t bytesToRead = wordCount * 2;
    for (uint16_t i = 0; i < bytesToRead; i++) 
    {
        // ¸¶Áö¸· ¹ÙÀÌÆ®¸¦ ÀÐÀ» ¶§´Â NACKÀ» º¸³½´Ù.
        bool send_ack = (i < (bytesToRead - 1));
        readBuffer[i] = I2C1_Read(send_ack);
    }

    // 4. I2C Åë½Å Á¾·á
    if (!I2C1_Stop()) return -1;
    
    return 0; // ¼º°ø
}

//
int Get_ZSSC4151_BridgeRaw(int16_t *raw_value)
{
    uint8_t raw_buffer[2]; // 2¹ÙÀÌÆ®¸¸ ¼ö½ÅÇÏ¹Ç·Î ¹öÆÛ Å©±â¸¦ 2·Î º¯°æ
    *raw_value = 0; // ¿¡·¯ ¹ß»ý ½Ã 0À» ¹ÝÈ¯ÇÏµµ·Ï ÃÊ±âÈ­

    // 1. Command Mode ÁøÀÔ
    if (ZSSC4151_EnterCommandMode() != 0) return -1;

    // 2. NVM ¼³Á¤°ªÀ» Shadow Register·Î º¹»ç
    if (ZSSC4151_CopyNvmToShadow() != 0) 
    {
        ZSSC4151_Start_Normal_Mode(); // ½ÇÆÐ ½Ã Normal ¸ðµå·Î º¹±Í ½Ãµµ
        return -1;
    }

    // 3. StrtMeasTask(0,0,0) Ä¿¸Çµå Àü¼Û
    if (ZSSC4151_StartMeasTask(0, 0, 0) != 0) 
    {
        ZSSC4151_Start_Normal_Mode();
        return -1;
    }

    // 4. ÃøÁ¤ ¿Ï·á ´ë±â (20ms)
    delay_10ms(2);

    // 5. RAM¿¡¼­ °á°ú°ª 1¿öµå(2¹ÙÀÌÆ®) ÀÐ±â
    // ZSSC4151_ReadRamBurstÀÇ µÎ ¹øÂ° ÀÎÀÚ¸¦ 1·Î º¯°æ
    if (ZSSC4151_ReadRamBurst(0x15, 1, raw_buffer) != 0) 
    {
        ZSSC4151_Start_Normal_Mode();
        return -1;
    }
    
    // 6. Normal Mode·Î º¹±Í
    if (ZSSC4151_Start_Normal_Mode() != 0) return -1;
    
    // 7. ÀÐ¾î¿Â 2¹ÙÀÌÆ®¸¦ 16ºñÆ® º¯¼ö·Î Á¶ÇÕ (Big-endian)
    *raw_value = ((uint16_t)raw_buffer[0] << 8) | raw_buffer[1];
            
    return 0; // ¸ðµç °úÁ¤ ¼º°ø
}

//
int ZSSC4151_CopyNvmToShadow(void)
{
    if (!I2C1_Start()) return -1;
    
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR)) 
    {
        I2C1_Stop();
        return -1;
    }
    
    if (!I2C1_Write(CMD_CP_NVM_TO_SHDW)) 
    {
        I2C1_Stop();
        return -1;
    }
    
    if (!I2C1_Stop()) return -1;

    // Ä¿¸Çµå ½ÇÇà ÈÄ ¾ÈÁ¤È­¸¦ À§ÇØ ¾à°£ÀÇ Áö¿¬ ½Ã°£À» ÁÝ´Ï´Ù.
    delay_us(500); 
    
    return 0;
}

/**
 * @brief Normal Mode¿¡¼­ I2C 'RdOutMemBurst (0x2E)' ¸í·ÉÀ¸·Î RAM °ªÀ» ÀÐ±â
 * @param address ÀÐ°íÀÚ ÇÏ´Â RAMÀÇ ½ÃÀÛ ÁÖ¼Ò
 * @param word_count ÀÐ¾î¿Ã ¿öµå(16ºñÆ®)ÀÇ °³¼ö
 * @param buffer µ¥ÀÌÅÍ¸¦ ¼ö½ÅÇÒ ¹öÆÛÀÇ Æ÷ÀÎÅÍ
 * @return ¼º°ø ½Ã 0, ½ÇÆÐ ½Ã À½¼ö ¿¡·¯ ÄÚµå
 */
int ZSSC4151_Read_Ram_In_Normal_Mode(uint8_t address, uint8_t word_count, uint8_t* buffer)
{
    // 1. I2C Start
    if (!I2C1_Start()) return -1;

    // 2. ½½·¹ÀÌºê ÁÖ¼Ò Àü¼Û (¾²±â ¸ðµå)
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop();
        return -2;
    }

    // 3. 'RdOutMemBurst' ¸í·É(0x2E) Àü¼Û
    if (!I2C1_Write(0x2E))
    {
        I2C1_Stop();
        return -3;
    }

    // 4. ÀÎ¼ö Àü¼Û: ½ÃÀÛ ÁÖ¼Ò(»óÀ§ ¹ÙÀÌÆ®)¿Í ¿öµå °³¼ö(ÇÏÀ§ ¹ÙÀÌÆ®)
    if (!I2C1_Write(address)) // »óÀ§ ¹ÙÀÌÆ®: RAM ½ÃÀÛ ÁÖ¼Ò
    {
        I2C1_Stop();
        return -4;
    }
    if (!I2C1_Write(word_count - 1)) // ÇÏÀ§ ¹ÙÀÌÆ®: ÀÐÀ» ¿öµå °³¼ö - 1
    {
        I2C1_Stop();
        return -5;
    }
    
    // 5. I2C Restart
    if (!I2C1_Restart()) return -6;

    // 6. ½½·¹ÀÌºê ÁÖ¼Ò Àü¼Û (ÀÐ±â ¸ðµå)
    if (!I2C1_Write(ZSSC4151_READ_ADDR))
    {
        I2C1_Stop();
        return -7;
    }

    // 7. µ¥ÀÌÅÍ ¼ö½Å
    for (uint8_t i = 0; i < (word_count * 2); i += 2)
    {
        buffer[i] = I2C1_Read(true); // MSB ¼ö½Å ÈÄ ACK
        buffer[i + 1] = I2C1_Read(i == (word_count * 2) - 2 ? false : true); // ¸¶Áö¸· ¹ÙÀÌÆ®´Â NACK, ±× ¿Ü¿¡´Â ACK
    }

    // 8. I2C Stop
    if (!I2C1_Stop()) return -8;

    return 0; // ¼º°ø
}

//
int ZSSC4151_ReadRam_Corrected(uint8_t address, uint8_t word_count, volatile uint8_t* buffer)
{
    // --- ¾²±â Æ®·£Àè¼Ç: ÀÐÀ» À§Ä¡ ÁöÁ¤ ---
    if (!I2C1_Start()) return -1;

    // 2. ½½·¹ÀÌºê ÁÖ¼Ò Àü¼Û (¾²±â ¸ðµå)
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop();
        return -2;
    }

    // 3. 'RdOutMemBurst' ¸í·É(0x2E) Àü¼Û
    if (!I2C1_Write(CMD_RD_OUT_MEM_BURST))
    {
        I2C1_Stop();
        return -3;
    }

    // 4. [¼öÁ¤µÊ] µ¥ÀÌÅÍ½ÃÆ®¿¡ µû¶ó 16ºñÆ® ÀÎ¼ö¸¦ »ý¼ºÇÏ°í Àü¼ÛÇÕ´Ï´Ù.
    // »óÀ§ 8ºñÆ®: ½ÃÀÛ ÁÖ¼Ò, ÇÏÀ§ 8ºñÆ®: ÀÐÀ» ¿öµå ¼ö - 1
    int16_t argument = ((int16_t)address << 8) | (word_count - 1);

    // 4-1. ÀÎ¼ö MSB Àü¼Û
    if (!I2C1_Write((uint8_t)(argument >> 8)))
    {
        I2C1_Stop();
        return -4;
    }
    // 4-2. ÀÎ¼ö LSB Àü¼Û
    if (!I2C1_Write((uint8_t)(argument & 0xFF)))
    {
        I2C1_Stop();
        return -5;
    }

    // --- ÀÐ±â Æ®·£Àè¼Ç: µ¥ÀÌÅÍ ¼ö½Å ---
    if (!I2C1_Restart()) return -6;

    // 6. ½½·¹ÀÌºê ÁÖ¼Ò Àü¼Û (ÀÐ±â ¸ðµå)
    if (!I2C1_Write(ZSSC4151_READ_ADDR))
    {
        I2C1_Stop();
        return -7;
    }

    // 7. [Ãß°¡µÊ] Ã¹ ¹ÙÀÌÆ®´Â Command Echo(0x2E)ÀÌ¹Ç·Î ÀÐ°í ¹ö¸³´Ï´Ù.
    (void)I2C1_Read(true);

    // 8. ½ÇÁ¦ µ¥ÀÌÅÍ¸¦ ¼ö½ÅÇÕ´Ï´Ù.
    int16_t bytesToRead = word_count * 2;
    for (int16_t i = 0; i < bytesToRead; i++)
    {
        bool is_last_byte = (i == (bytesToRead - 1));
        buffer[i] = I2C1_Read(!is_last_byte); // ¸¶Áö¸· ¹ÙÀÌÆ® Àü±îÁö´Â ACK, ¸¶Áö¸· ¹ÙÀÌÆ®´Â NACK
    }

    // 9. I2C Stop
    if (!I2C1_Stop()) return -8;

    return 0; // ¼º°ø
}

/**
 * @brief ZSSC4151¿¡°Ô ÀüÃ¼ ÃøÁ¤ »çÀÌÅ¬À» ½ÃÀÛÇÏ¶ó°í ¸í·ÉÇÕ´Ï´Ù. (StrtMeasCyc, 0x0B)
 * @details Command Mode¿¡¼­¸¸ ½ÇÇàÇØ¾ß ÇÕ´Ï´Ù. ÀÌ ÇÔ¼ö ½ÇÇà ÈÄ¿¡µµ Command Mode´Â À¯ÁöµË´Ï´Ù.
 * @return ¼º°ø ½Ã 0, ½ÇÆÐ ½Ã -1
 */
int ZSSC4151_StartMeasCycle(void)
{
    // 1. I2C Åë½Å ½ÃÀÛ
    if (!I2C1_Start()) return -1;

    // 2. ½½·¹ÀÌºê ÁÖ¼Ò(¾²±â) Àü¼Û
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR))
    {
        I2C1_Stop();
        return -2;
    }

    // 3. StrtMeasCyc Ä¿¸Çµå(0x0B) Àü¼Û
    if (!I2C1_Write(CMD_STRT_MEAS_CYC))    
    {
        I2C1_Stop();
        return -3;
    }

    // 4. µ¥ÀÌÅÍ½ÃÆ®¿¡ µû¸£¸é StrtMeasCyc´Â 16ºñÆ® ÀÎ¼ö¸¦ ¹Þ½À´Ï´Ù.
    // ÀÏ¹ÝÀûÀÎ »ç¿ë »ç·Ê¿¡¼­´Â ÀÌ ÀÎ¼ö¸¦ 0À¸·Î ¼³Á¤ÇÕ´Ï´Ù.
    // Argument: strtMeasCycArg, 16 Bits
    if (!I2C1_Write(0x00)) // Argument MSB
    {
        I2C1_Stop();
        return -4;
    }
    if (!I2C1_Write(0x00)) // Argument LSB
    {
        I2C1_Stop();
        return -5;
    }

    // 5. I2C Åë½Å Á¾·á
    if (!I2C1_Stop()) return -6;

    return 0;
}

/**
 * @brief RAM¿¡ ÀÖ´Â ¿ø½Ã µ¥ÀÌÅÍ¸¦ ¹ÙÅÁÀ¸·Î ¿¬»ê »çÀÌÅ¬À» ½ÇÇàÇÕ´Ï´Ù. (RunCondCyc, 0x0E)
 * @details ÀÌ ¸í·É ÈÄ RAM 0x41 µî¿¡ ÃÖÁ¾ °á°ú°ªÀÌ ±â·ÏµË´Ï´Ù.
 * @return ¼º°ø ½Ã 0, ½ÇÆÐ ½Ã -1
 */
int ZSSC4151_RunConditioningCycle(void)
{
    if (!I2C1_Start()) return -1;
    if (!I2C1_Write(ZSSC4151_WRITE_ADDR)) { I2C1_Stop(); return -2; }
    if (!I2C1_Write(CMD_RUN_COND_CYC)) { I2C1_Stop(); return -3; }
    // RunCondCyc ¶ÇÇÑ 16ºñÆ® ÀÎ¼ö¸¦ ¹ÞÀ¸¸ç, º¸Åë 0À¸·Î ¼³Á¤ÇÕ´Ï´Ù.
    if (!I2C1_Write(0x00)) { I2C1_Stop(); return -4; } // Argument MSB
    if (!I2C1_Write(0x00)) { I2C1_Stop(); return -5; } // Argument LSB
    if (!I2C1_Stop()) return -6;
    return 0;
}

/**
 * @brief ZSSC4151ÀÇ »óÅÂ ·¹Áö½ºÅÍ(IC Status, Failure Status)¸¦ ÀÐ¾î Ãâ·ÂÇÕ´Ï´Ù.
 */
void ZSSC4151_Check_Status_Registers(void)
{
    uint32_t status_val;

    // IC Status ÀÐ±â (0x60)
    if (ZSSC4151_Read_Command_Response32(CMD_RD_IC_STATUS, &status_val) == 0)
    {
        dbg_put_string(" -> IC Status (0x60): 0x");
        dbg_put_hex_word((uint16_t)(status_val >> 16));
        dbg_put_hex_word((uint16_t)(status_val & 0xFFFF));
        dbg_put_string("\r\n");
    }
    else
    {
        dbg_put_string(" -> Failed to read IC Status (0x60)\r\n");
    }

    // Failure Status ÀÐ±â (0x62)
    if (ZSSC4151_Read_Command_Response32(CMD_RD_FAILURE_STATUS, &status_val) == 0)
    {
        dbg_put_string(" -> Failure Status (0x62): 0x");
        dbg_put_hex_word((uint16_t)(status_val >> 16));
        dbg_put_hex_word((uint16_t)(status_val & 0xFFFF));
        dbg_put_string("\r\n");
    }
    else
    {
        dbg_put_string(" -> Failed to read Failure Status (0x62)\r\n");
    }
}